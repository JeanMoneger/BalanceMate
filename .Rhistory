agg_result[[paste0("SD_", col)]] <- mat[, "SD"]
agg_result[[col]] <- NULL
}
# Return the result
return(agg_result)
}
test2<-Epoch_SliceR2_base(Data, ID = "file_name", c("CoP_X", "CoP_Y"), 165, 100, 331)
#'
#' @return a data frame that should be shorter.
#' @export
#'
#' @examples
#' path_to_data <- system.file("extdata", package = "BalanceMate") #Find subdirectory of Example data in the original .txt format exported from AMTI Netforce software
#' Data <- Merge_PosData(path_to_data, SampleRate = 100, SessionDuration = 331)
#'
#' Epoch_SliceR(df = Data, ID = "file_name", columns_to_synthesize = c("CoP_X", "CoP_Y"), epoch_length = 1, sample_rate=100, session_duration = 331)
#'
Epoch_SliceR <- function(df, ID, columns_to_synthesize, epoch_length, sample_rate, session_duration) {
# [Input validation code remains the same]
# Calculate samples per epoch and expected samples per participant
samples_per_epoch <- sample_rate * epoch_length
expected_samples_per_participant <- sample_rate * session_duration
# Get unique participant IDs
participant_ids <- unique(df[[ID]])
# Initialize list to hold results
result_list <- list()
# Process each participant individually
for (participant in participant_ids) {
# Subset data for the participant
participant_data <- df[df[[ID]] == participant, ]
actual_samples <- nrow(participant_data)
# [Warning for sample mismatch remains the same]
# Assign epoch numbers using integer division
epoch_numbers <- ((seq_len(actual_samples) - 1) %/% samples_per_epoch) + 1
participant_data$Epoch <- epoch_numbers
# [Warning for incomplete final epoch remains the same]
# Initialize result data frame for this participant
participant_result <- data.frame(ID = participant, Epoch = unique(epoch_numbers))
# Compute statistics for each column to synthesize
for (col in columns_to_synthesize) {
# Aggregate mean and standard deviation per epoch
agg_result <- aggregate(participant_data[[col]], by = list(Epoch = participant_data$Epoch),
FUN = function(x) c(mean(x, na.rm = TRUE), sd(x, na.rm = TRUE)))
# Split the aggregated values into mean and standard deviation
stats <- matrix(unlist(agg_result$x), ncol = 2, byrow = TRUE)
colnames(stats) <- c(paste0("Mean_", col), paste0("SD_", col))
# Merge the statistics into the participant's result data frame
participant_result <- merge(participant_result, data.frame(Epoch = agg_result$Epoch, stats), by = "Epoch")
}
# Add the participant's result to the list
result_list[[as.character(participant)]] <- participant_result
}
# Combine all participant results into one data frame
result <- do.call(rbind, result_list)
# Reset row names
rownames(result) <- NULL
# Return the result
return(result)
}
#'
#' @return a data frame that should be shorter.
#' @export
#'
#' @examples
#' path_to_data <- system.file("extdata", package = "BalanceMate") #Find subdirectory of Example data in the original .txt format exported from AMTI Netforce software
#' Data <- Merge_PosData(path_to_data, SampleRate = 100, SessionDuration = 331)
#'
#' Epoch_SliceR(df = Data, ID = "file_name", columns_to_synthesize = c("CoP_X", "CoP_Y"), epoch_length = 1, sample_rate=100, session_duration = 331)
#'
Epoch_SliceR <- function(df, ID, columns_to_synthesize, epoch_length, sample_rate, session_duration) {
# [Input validation code remains the same]
# Calculate samples per epoch and expected samples per participant
samples_per_epoch <- sample_rate * epoch_length
expected_samples_per_participant <- sample_rate * session_duration
# Get unique participant IDs
participant_ids <- unique(df[[ID]])
# Initialize list to hold results
result_list <- list()
# Process each participant individually
for (participant in participant_ids) {
# Subset data for the participant
participant_data <- df[df[[ID]] == participant, ]
actual_samples <- nrow(participant_data)
# [Warning for sample mismatch remains the same]
# Assign epoch numbers using integer division
epoch_numbers <- ((seq_len(actual_samples) - 1) %/% samples_per_epoch) + 1
participant_data$Epoch <- epoch_numbers
# [Warning for incomplete final epoch remains the same]
# Initialize result data frame for this participant
participant_result <- data.frame(ID = participant, Epoch = unique(epoch_numbers))
# Compute statistics for each column to synthesize
for (col in columns_to_synthesize) {
# Aggregate mean and standard deviation per epoch
agg_result <- aggregate(participant_data[[col]], by = list(Epoch = participant_data$Epoch),
FUN = function(x) c(mean(x, na.rm = TRUE), sd(x, na.rm = TRUE)))
# Split the aggregated values into mean and standard deviation
stats <- matrix(unlist(agg_result$x), ncol = 2, byrow = TRUE)
colnames(stats) <- c(paste0("Mean_", col), paste0("SD_", col))
# Merge the statistics into the participant's result data frame
participant_result <- merge(participant_result, data.frame(Epoch = agg_result$Epoch, stats), by = "Epoch")
}
# Add the participant's result to the list
result_list[[as.character(participant)]] <- participant_result
}
# Combine all participant results into one data frame
result <- do.call(rbind, result_list)
# Reset row names
rownames(result) <- NULL
# Return the result
return(result)
}
test<-Epoch_SliceR(df = Data, ID = "file_name", columns_to_synthesize = c("CoP_X", "CoP_Y"), epoch_length = 331, sample_rate=100, session_duration = 331)
test
Epoch_SliceR2 <- function(df, ID, columns_to_synthesize, epoch_length, sample_rate, session_duration) {
# Input validation
# Check that all columns in ID exist in df
missing_id_cols <- setdiff(ID, names(df))
if (length(missing_id_cols) > 0) {
stop(paste("ID column(s)", paste(missing_id_cols, collapse = ", "), "not found in the data frame."))
}
# Check that columns_to_synthesize is a vector of one or two column names
if (length(columns_to_synthesize) < 1 || length(columns_to_synthesize) > 2) {
stop("columns_to_synthesize must be a vector containing one or two column names.")
}
# Check that the specified columns exist and are numeric
for (col in columns_to_synthesize) {
if (!col %in% names(df)) {
stop(paste("Column", col, "not found in the data frame."))
}
if (!is.numeric(df[[col]])) {
stop(paste("Column", col, "is not numeric."))
}
}
# Check that epoch_length, sample_rate, session_duration are positive numbers
if (!is.numeric(epoch_length) || epoch_length <= 0) {
stop("epoch_length must be a positive numeric value.")
}
if (!is.numeric(sample_rate) || sample_rate <= 0) {
stop("sample_rate must be a positive numeric value.")
}
if (!is.numeric(session_duration) || session_duration <= 0) {
stop("session_duration must be a positive numeric value.")
}
# Calculate samples per epoch and expected samples per participant
samples_per_epoch <- sample_rate * epoch_length
expected_samples_per_participant <- sample_rate * session_duration
# Assign row numbers and epoch numbers
df <- df %>%
group_by(across(all_of(ID))) %>%
mutate(
RowNumber = row_number(),
Epoch = ceiling(RowNumber / samples_per_epoch)
) %>%
ungroup()
# Check for mismatches in expected samples per participant
sample_counts <- df %>%
group_by(across(all_of(ID))) %>%
summarise(
ActualSamples = n(),
.groups = 'drop'
)
mismatched_samples <- sample_counts %>%
filter(ActualSamples != expected_samples_per_participant)
if (nrow(mismatched_samples) > 0) {
warning("Some participants have mismatched sample counts:")
print(mismatched_samples)
}
# Warn about incomplete epochs
incomplete_epochs <- df %>%
group_by(across(all_of(ID)), Epoch) %>%
summarise(
EpochSamples = n(),
.groups = 'drop_last'
) %>%
filter(EpochSamples < samples_per_epoch)
if (nrow(incomplete_epochs) > 0) {
warning("Some participants have incomplete final epochs:")
print(incomplete_epochs)
}
# Compute mean and sd per epoch for each participant
result <- df %>%
group_by(across(all_of(ID)), Epoch) %>%
summarise(
across(
all_of(columns_to_synthesize),
list(Mean = ~mean(.x, na.rm = TRUE), SD = ~sd(.x, na.rm = TRUE)),
.names = "{.fn}_{.col}"
),
.groups = 'drop'
)
# Return the result
return(result)
}
Epoch_SliceR2(df = Data, ID = "file_name", columns_to_synthesize = c("CoP_X", "CoP_Y"), epoch_length = 331, sample_rate=100, session_duration = 331)
Epoch_SliceR(df = Data, ID = "file_name", columns_to_synthesize = c("CoP_X", "CoP_Y"), epoch_length = 331, sample_rate=100, session_duration = 331)
Epoch_SliceR(df = Data, ID = "file_name", columns_to_synthesize = c("CoP_X", "CoP_Y"), epoch_length = 115, sample_rate=100, session_duration = 331)
Epoch_SliceR2(df = Data, ID = "file_name", columns_to_synthesize = c("CoP_X", "CoP_Y"), epoch_length = 115, sample_rate=100, session_duration = 331)
Epoch_SliceR2(df = Data, ID = "file_name", columns_to_synthesize = c("CoP_X", "CoP_Y"), epoch_length = 115.5, sample_rate=100, session_duration = 331)
331/2
Epoch_SliceR2(df = Data, ID = "file_name", columns_to_synthesize = c("CoP_X", "CoP_Y"), epoch_length = 165.5, sample_rate=100, session_duration = 331)
Epoch_SliceR(df = Data, ID = "file_name", columns_to_synthesize = c("CoP_X", "CoP_Y"), epoch_length = 165.5, sample_rate=100, session_duration = 331)
#'
#' @return a data frame that should be shorter.
#' @export
#'
#' @examples
#' path_to_data <- system.file("extdata", package = "BalanceMate") #Find subdirectory of Example data in the original .txt format exported from AMTI Netforce software
#' Data <- Merge_PosData(path_to_data, SampleRate = 100, SessionDuration = 331)
#'
#' Epoch_SliceR(df = Data, ID = "file_name", columns_to_synthesize = c("CoP_X", "CoP_Y"), epoch_length = 1, sample_rate=100, session_duration = 331)
#'
Epoch_SliceR <- function(df, ID, columns_to_synthesize, epoch_length, sample_rate, session_duration) {
# Check that ID column exists in df
if (!ID %in% names(df)) {
stop(paste("ID column", ID, "not found in the data frame."))
}
# Check that columns_to_synthesize is a vector of one or more column names
if (length(columns_to_synthesize) < 1) {
stop("columns_to_synthesize must be a vector containing at least one column name.")
}
# Check that the specified columns exist and are numeric
for (col in columns_to_synthesize) {
if (!col %in% names(df)) {
stop(paste("Column", col, "not found in the data frame."))
}
if (!is.numeric(df[[col]])) {
stop(paste("Column", col, "is not numeric."))
}
}
# Check that epoch_length, sample_rate, session_duration are positive numbers
if (!is.numeric(epoch_length) || epoch_length <= 0) {
stop("epoch_length must be a positive numeric value.")
}
if (!is.numeric(sample_rate) || sample_rate <= 0) {
stop("sample_rate must be a positive numeric value.")
}
if (!is.numeric(session_duration) || session_duration <= 0) {
stop("session_duration must be a positive numeric value.")
}
# Calculate samples per epoch and expected samples per participant
samples_per_epoch <- sample_rate * epoch_length
expected_samples_per_participant <- sample_rate * session_duration
# Get unique participant IDs
participant_ids <- unique(df[[ID]])
# Initialize list to hold results
result_list <- list()
# Process each participant individually
for (participant in participant_ids) {
# Subset data for the participant
participant_data <- df[df[[ID]] == participant, ]
actual_samples <- nrow(participant_data)
# Check if actual samples match expected samples
if (actual_samples != expected_samples_per_participant) {
warning(sprintf("Participant '%s' has %d samples; expected %d samples.", participant, actual_samples, expected_samples_per_participant))
}
# Assign epoch numbers using integer division
epoch_numbers <- ((seq_len(actual_samples) - 1) %/% samples_per_epoch) + 1
participant_data$Epoch <- epoch_numbers
# Warn if the last epoch is incomplete (has fewer samples than expected)
last_epoch_samples <- actual_samples %% samples_per_epoch
if (last_epoch_samples > 0 && last_epoch_samples < samples_per_epoch) {
warning(sprintf("Participant '%s' has an incomplete final epoch with only %d samples (expected %d samples per epoch).",
participant, last_epoch_samples, samples_per_epoch))
}
# Initialize result data frame for this participant
participant_result <- data.frame(ID = participant, Epoch = unique(epoch_numbers))
# Compute statistics for each column to synthesize
for (col in columns_to_synthesize) {
# Aggregate mean and standard deviation per epoch
agg_result <- aggregate(participant_data[[col]], by = list(Epoch = participant_data$Epoch),
FUN = function(x) c(Mean = mean(x, na.rm = TRUE), SD = sd(x, na.rm = TRUE)))
# Convert the list column into a data frame
stats <- do.call(rbind, agg_result$x)
stats <- as.data.frame(stats)
# Create column names
colnames(stats) <- c(paste0("Mean_", col), paste0("SD_", col))
# Merge the statistics into the participant's result data frame
participant_result <- merge(participant_result, data.frame(Epoch = agg_result$Epoch, stats), by = "Epoch")
}
# Add the participant's result to the list
result_list[[as.character(participant)]] <- participant_result
}
# Combine all participant results into one data frame
result <- do.call(rbind, result_list)
# Reset row names
rownames(result) <- NULL
# Return the result
return(result)
}
Epoch_SliceR(df = Data, ID = "file_name", columns_to_synthesize = c("CoP_X", "CoP_Y"), epoch_length = 165.5, sample_rate=100, session_duration = 331)
#'
#' @return a data frame that should be shorter.
#' @export
#'
#' @examples
#' path_to_data <- system.file("extdata", package = "BalanceMate") #Find subdirectory of Example data in the original .txt format exported from AMTI Netforce software
#' Data <- Merge_PosData(path_to_data, SampleRate = 100, SessionDuration = 331)
#'
#' Epoch_SliceR(df = Data, ID = "file_name", columns_to_synthesize = c("CoP_X", "CoP_Y"), epoch_length = 1, sample_rate=100, session_duration = 331)
#'
Epoch_SliceR <- function(df, ID, columns_to_synthesize, epoch_length, sample_rate, session_duration) {
# Input validation remains the same
# Calculate samples per epoch and expected samples per participant
samples_per_epoch <- sample_rate * epoch_length
expected_samples_per_participant <- sample_rate * session_duration
# Get unique participant IDs
participant_ids <- unique(df[[ID]])
# Initialize list to hold results
result_list <- list()
# Process each participant individually
for (participant in participant_ids) {
# Subset data for the participant
participant_data <- df[df[[ID]] == participant, ]
actual_samples <- nrow(participant_data)
# Check if actual samples match expected samples
if (actual_samples != expected_samples_per_participant) {
warning(sprintf("Participant '%s' has %d samples; expected %d samples.", participant, actual_samples, expected_samples_per_participant))
}
# Assign epoch numbers using integer division
epoch_numbers <- ((seq_len(actual_samples) - 1) %/% samples_per_epoch) + 1
participant_data$Epoch <- epoch_numbers
# Warn if the last epoch is incomplete (has fewer samples than expected)
last_epoch_samples <- actual_samples %% samples_per_epoch
if (last_epoch_samples > 0 && last_epoch_samples < samples_per_epoch) {
warning(sprintf("Participant '%s' has an incomplete final epoch with only %d samples (expected %d samples per epoch).",
participant, last_epoch_samples, samples_per_epoch))
}
# Initialize result data frame for this participant
participant_result <- data.frame(ID = participant, Epoch = unique(epoch_numbers))
# Compute statistics for each column to synthesize
for (col in columns_to_synthesize) {
# Compute mean per epoch
mean_result <- aggregate(participant_data[[col]], by = list(Epoch = participant_data$Epoch),
FUN = mean, na.rm = TRUE)
colnames(mean_result)[2] <- paste0("Mean_", col)
# Compute sd per epoch
sd_result <- aggregate(participant_data[[col]], by = list(Epoch = participant_data$Epoch),
FUN = sd, na.rm = TRUE)
colnames(sd_result)[2] <- paste0("SD_", col)
# Merge mean and sd
agg_result <- merge(mean_result, sd_result, by = "Epoch")
# Merge into participant_result
participant_result <- merge(participant_result, agg_result, by = "Epoch")
}
# Add the participant's result to the list
result_list[[as.character(participant)]] <- participant_result
}
# Combine all participant results into one data frame
result <- do.call(rbind, result_list)
# Reset row names
rownames(result) <- NULL
# Return the result
return(result)
}
Epoch_SliceR(df = Data, ID = "file_name", columns_to_synthesize = c("CoP_X", "CoP_Y"), epoch_length = 165.5, sample_rate=100, session_duration = 331)
Epoch_SliceR2(df = Data, ID = "file_name", columns_to_synthesize = c("CoP_X", "CoP_Y"), epoch_length = 165.5, sample_rate=100, session_duration = 331)
Epoch_SliceR(df = Data, ID = "file_name", columns_to_synthesize = c("CoP_X", "CoP_Y"), epoch_length = 162, sample_rate=100, session_duration = 331)
Epoch_SliceR(df = Data, ID = "file_name", columns_to_synthesize = c("CoP_X", "CoP_Y"), epoch_length = 1, sample_rate=100, session_duration = 331)
sessionInfo()
library(signal)
sessionInfo()
?signal
#' @examples
#' # Assuming 'Data' is your data frame with columns 'CoP_X' and 'CoP_Y'
#' filtered_data <- Filter_CoP(
#'   Data = Data,
#'   cutoff_freq = 5,
#'   filter_order = 2,
#'   sampling_rate = 100,
#'   type = "low",
#'   Colname = c("CoP_X", "CoP_Y")
#' )
Butterworth_it <- function(Data, cutoff_freq, filter_order, sampling_rate, type = "low", Colname) {
# Validate inputs
if (!is.data.frame(Data)) {
stop("Data must be a data frame.")
}
if (!all(Colname %in% names(Data))) {
missing_cols <- Colname[!Colname %in% names(Data)]
stop(paste("The following columns are not in Data:", paste(missing_cols, collapse = ", ")))
}
if (!type %in% c("low", "high")) {
stop("Type must be either 'low' or 'high'.")
}
# Create the Butterworth filter
butter_filter <- signal::butter(
n = filter_order,
W = cutoff_freq / (sampling_rate / 2),
type = type
)
# Apply the filter to the specified columns
for (col in Colname) {
# Apply zero-phase filtering
filtered_signal <- signal::filtfilt(butter_filter, Data[[col]])
# Add the filtered data to the Data frame
Data[[paste0(col, "_filtered")]] <- filtered_signal
}
# Return the Data frame with filtered columns added
return(Data)
}
filtered_data <- Butterworth_it(
Data = Data,
cutoff_freq = 5,
filter_order = 2,
sampling_rate = 100,
type = "low",
Colname = c("CoP_X", "CoP_Y")
)
head(filtered_data)
par(mfrow = c(1,2))
plot(x = filtered_data$Time, y = filtered_data$CoP_X, type ="l", tck = 1, main = "Non filtered")
plot(x = filtered_data$Time, y = filtered_data$CoP_X, type ="l", tck = 1, main = "Non filtered")
subsetTest<- subset(filtered_data, filtered_data$file_name == "Postural_DataA.txt" & filtered_data$Time < 10)
plot(x = subsetTest$Time, y = subsetTest$CoP_X, type ="l", tck = 1, main = "Non filtered")
plot(x = subsetTest$Time, y = subsetTest$CoP_X_filtered, type ="l", tck = 1, main = "filtered")
plot(x = subsetTest$Time, y = subsetTest$CoP_Y, type ="l", tck = 1, main = "Non filtered")
plot(x = subsetTest$Time, y = subsetTest$CoP_Y_filtered, type ="l", tck = 1, main = "filtered")
compute_ellipse_area <- function(data, CoPX_col, CoPY_col, ID, time_col = NULL, epoch_length = NULL, confint = .95) {
# Check if columns exist in the data frame
if (!(CoPX_col %in% colnames(data))) stop(paste("Column", CoPX_col, "not found in the data frame"))
if (!(CoPY_col %in% colnames(data))) stop(paste("Column", CoPY_col, "not found in the data frame"))
if (!(ID %in% colnames(data))) stop(paste("Column", ID, "not found in the data frame"))
# Extract necessary columns
CoPX <- data[[CoPX_col]]
CoPY <- data[[CoPY_col]]
participant_id <- data[[ID]]
# Create grouping variable
if (!is.null(epoch_length) && !is.null(time_col)) {
if (!(time_col %in% colnames(data))) stop(paste("Column", time_col, "not found in the data frame"))
time <- data[[time_col]]
# Create epochs
max_epoch <- ceiling(max(time) / epoch_length)
# Create epochs, ensuring they do not exceed max_epoch
data$epoch <- pmin(floor(time / epoch_length) + 1, max_epoch)
# Create grouping variable for participant and epoch
data$group <- interaction(participant_id, data$epoch, drop = TRUE)  } else {
# Group by participant only if no epoch is provided
data$group <- as.character(participant_id)
}
# Incomplete epoch?
if (!is.null(epoch_length) && !is.null(time_col)) {
if (((nrow(data)/length(table(participant_id)))/100/epoch_length) %% 1 != 0) {
warning(paste("Unbalanced epochs detected -- Epoch is not a multiple of protocol duration"))
}
}
# Split data by group (participant + epoch, or participant only)
data_list <- split(data, data$group)
# Chi-squared quantile for the specified confidence interval with 2 degrees of freedom
chi_squared_quantile <- qchisq(confint, df = 2)
# Function to compute ellipse area for each group
compute_ellipse <- function(subset_data) {
if (nrow(subset_data) < 2) {
return(NA)  # Not enough data to compute covariance
} else {
cov_matrix <- cov(subset_data[, c(CoPX_col, CoPY_col)])
eigenvalues <- eigen(cov_matrix)$values
if (any(eigenvalues <= 0)) {
return(NA)  # Covariance matrix is singular or not positive-definite
} else {
# Corrected formula for ellipse area
ellipse_area <- pi * chi_squared_quantile * sqrt(prod(eigenvalues))
return(ellipse_area)
}
}
}
# Apply the function to each group
ellipse_values <- sapply(data_list, compute_ellipse)
# Prepare the result based on whether epoch was used or not
if (!is.null(epoch_length) && !is.null(time_col)) {
# Split the group back into participant and epoch
group_info <- do.call(rbind, strsplit(names(ellipse_values), split = '\\.'))
# Ensure epochs are numeric
result <- data.frame(
participant_id = group_info[,1],
epoch = as.numeric(group_info[, ncol(group_info)]),
ellipse_area = ellipse_values,
stringsAsFactors = FALSE
)
} else {
# No epoch, so only return participant and ellipse area
result <- data.frame(
participant_id = names(ellipse_values),
ellipse_area = ellipse_values,
stringsAsFactors = FALSE
)
}
# Order the result based on participant_id and epoch (if applicable)
if ("epoch" %in% colnames(result)) {
result <- result[order(result$participant_id, result$epoch), ]
} else {
result <- result[order(result$participant_id), ]
}
return(result)
} # Results are consistent with AMTI BioAnalysis outputs
compute_ellipse_area(Data, "CoP_X", "CoP_Y", ID = "file_name")
compute_ellipse_area(Data, "CoP_X", "CoP_Y", ID = "file_name", time_col = "Time", epoch_length = 1)
compute_ellipse_area(Data, "CoP_X", "CoP_Y", ID = "file_name", time_col = "Time", epoch_length = 1, confint = .8)
install.packages("bookdown")
install.packages("bookdown")
library(bookdown)
?bookdown
install.packages("bookdown")
library(bookdown)
install.packages("xfun")
install.packages("xfun")
library(bookdown)
install.packages('xfun')
install.packages("xfun")
Yes
install.packages("xfun")
install.packages("bookdown")
library(bookdown)
